from __future__ import annotations # necessary for type-guarding class methods
from dataclasses import dataclass, field, asdict
from typing import Optional, Any
from parsl.data_provider.files import File
from lib.papps import app_get_snaps_from_traj, app_create_supercell, app_scale_cell, app_get_weighted_random_snap, app_transform_lower_triangular, app_set_most_ortho_forall
from lib.papps import app_get_min_struc, app_create_pickle_hes, app_create_pickle_vacf, app_create_pickle_lmdTI, app_create_pickle_temTI, app_create_pickle_nptd
from lib.run_papps import app_run_MD, app_run_REX, app_optimize, app_calc_hessian, app_run_recalc
import numpy as np
import os
from pathlib import Path
import time                             #Needed to perform a restart, via the read function we enforce the original app to be finished


@dataclass
class Settings:
    num_cores        : int                  = 1                           #number of cores used for the MD simulations
    device           : str                  = "cpu"                       #cpu or cuda
    #Settings related to the creation of the input structure
    set_vel          : bool                 = True
    trans_mat        : Optional[np.float]   = None                        #workflow setting 
    #MD settings
    nsteps           : Optional[int]        = None                        #For MD, total number of steps. For REX, number of MC steps
    print_freq       : int                  = 100                         #print frequency for the MD simulations
    temperature      : Optional[np.float]   = None                        #np.array
    pressure         : Optional[np.float]   = None                        #np.array
    barostat         : Optional[str]        = "Langevin"                  #Langevin or MC
    frac_MLP         : Optional[np.float]   = 1.0                         #np.array
    frac_bias        : Optional[np.float]   = 0.0                         #np.array
    #REX settings
    MD_steps_REX     : int                  = None                        #number of MD steps for the REX simulation
    #Optimization settings
    fmax             : float                = 1e-4                        #Convergence threshold for the forces in eV/Ang for the optimization
    #Settings to recalculate the difference between two PES
    MLP_beg          : float                = None                       
    MLP_end          : float                = None 
    bias_beg         : float                = None
    bias_end         : float                = None
    #For post-processing
    calib_steps      : int                  = None
    

class Simulation:
    settings         : Optional[Settings]   = None
    input_folder     : Optional[Any]        = None
    output_folder    : Optional[Any]        = None
    MLP_model_dct    : Optional[Any]        = None     
    min_struc        : Optional[Any]        = None   
    Hessian_npy      : Optional[Any]        = None              
    Hessian_model    : Optional[Any]        = None               
    num_val_prop     : int                  = 1
    num_runs         : int                  = 1
    num_retries      : int                  = 5                           #How many times an MD simulations is retried after the MLP predicts forces exceeding a threshold
    suffix           : Optional[list]       = None                        #Is typically set by create settings based on the input settings
    #Dependency on previous simulations
    pre_Files        : Optional[list]       = None
    pre_simulation   : Optional[Simulation] = None
    pre_val          : Optional[int]        = None                         #Which settings of the previous simulation to use, None means all, otherwise select 1
    ref_cell         : Optional[Any]        = None                         #Reference cell for scaling other snapshots if necessary
    ref_pickle_file_lst : Optional[Any]     = None                         #Pickle file of an other simulation, to get its free energy
    #Files - normally generated by apps
    input_files      : Optional[list[list]] = None
    output_files     : Optional[list[list]] = None
    output_files_rec : Optional[list[list]] = None
    pickle_file      : Optional[list]       = None

    def __init__(self, **kwargs): 
        for key, val in kwargs.items():
            assert key in self.__dir__(), f"key {key} not in Simulation class"
            setattr(self, key, val)
        #Try to create the input and output folders
        self.input_folder.mkdir(exist_ok=True)
        self.output_folder.mkdir(exist_ok=True)

    def create_settings(self, **kwargs):
        """
        Create the settings for the simulations
        inputs:
            kwargs: Dictionary, the settings for the simulations
        outputs:
            - Sets the settings attribute of the Simulation object
            - Creates numpy arrays for the temperature, pressure, frac_MLP and frac_bias attributes of the settings attribute such that they are numpy arrays 
            with the correct length
            - Sets suffix list to give the correct names to the output files
        """
        #Create the settings
        self.settings = Settings(**kwargs)                                 #Make sure that all kwargs are attributes of the Settings class
        #Create the numpy arrays if necessary
        for key, val in asdict(self.settings).items():
            if key in ["temperature", "pressure", "frac_MLP", "frac_bias"]:
                if val is None or np.isscalar(val):
                    setattr(self.settings, key, np.array([val]*self.num_val_prop))
                else:
                    assert len(val) == self.num_val_prop, "The length of the {} array is not equal to the number of validation properties".format(key)
        #Create the suffix list if necessary
        self.suffix = []
        if self.settings.temperature[0] != self.settings.temperature[-1]:
            for i, tem in enumerate(self.settings.temperature):
                assert str(int(tem)) != str(int(self.settings.temperature[(i+1)%self.num_val_prop])), "Two rounded temperatures are the same"
                self.suffix.append("_T"+ str(int(tem)))
        elif self.settings.frac_MLP[0] != self.settings.frac_MLP[-1]:
            for i, fmlp in enumerate(self.settings.frac_MLP):
                assert str(int(fmlp))!= str(self.settings.frac_MLP[(i+1)%self.num_val_prop]), "Two biases are the same"
                #make string of rounded floats
                for i in range(10):
                    rounded_fmlp = np.round(fmlp, i)
                    if np.abs(rounded_fmlp - fmlp) < 1e-7:
                        break
                self.suffix.append("_lm"+ str(rounded_fmlp).replace(".","_"))
        elif self.settings.frac_bias[0] != self.settings.frac_bias[-1]:
            for i, fb in enumerate(self.settings.frac_bias):
                assert str(int(fb))!= str(self.settings.frac_bias[(i+1)%self.num_val_prop]), "Two biases are the same"
                #make string of rounded floats
                for i in range(10):
                    rounded_fb = np.round(fb, i)
                    if np.abs(rounded_fb - fb) < 1e-7:
                        break
                self.suffix.append("_lb"+ str(rounded_fb).replace(".","_"))
        else:
            self.suffix = [""]*self.num_val_prop

    def get_input_struc(self, transform_low_tri = False, sup = False, scale_cell = False, set_most_ortho= False, old_files = 0, pre_files_ignore = 0, remove_existing_from_reshape = False):
        """
        Get the input structure for the MD runs
        inputs:
            transform_low_tri: Boolean, if True, the input structure is put in lower triangular matrix form
            sup: Boolean, if True, the input structure is the supercell of the previous run, the trans_mat attribute has to be set
            scale_cell: Boolean, if True, the input structure is scaled to the reference cell that has to be set
            old_files: Integer, the number of files already present in the input folder, which will be ignored
            pre_files_ignore: Integer, the number of files already present in the pre_simulation output folder, which will be ignored
            remove_existing_from_reshape: Boolean, if True, the existing files in the input folder will be removed from the reshape
        outputs:
            sets the input_files attribute of the Simulation object, a double nested list of File objects, with the first index corresponds 
            to runs at different settings and the second index corresponds to runs with the same settings
        """
        
        F_atoms= []
        for i in range(self.num_val_prop):
            F_atoms.append([])
            for j in range(old_files, self.num_runs):
                F_atoms[i].append(File(str(self.input_folder / str("atoms"+self.suffix[i]+"_"+str(j)+".xyz"))))

        if self.pre_simulation != None:
            if len(self.pre_simulation.output_files) == 1 or self.pre_val != None:
                if self.pre_val == None:
                    self.pre_val = 0
                per_pre_file = (self.num_runs-old_files)*self.num_val_prop/ len(self.pre_simulation.output_files[self.pre_val][pre_files_ignore:])
                if per_pre_file > 1.0:
                    for k, F_pre in enumerate(self.pre_simulation.output_files[self.pre_val][pre_files_ignore:]):
                        F_atoms_reshape = []
                        for i in range(self.num_runs-old_files):
                            for j in range(self.num_val_prop):
                                if (k*per_pre_file <= i*self.num_val_prop+j) and (i*self.num_val_prop+j < (k+1)*per_pre_file):
                                    F_atoms_reshape.append(F_atoms[j][old_files+ i])
                        if remove_existing_from_reshape == True:
                            for Fat in F_atoms_reshape:
                                if os.path.exists(Fat.filepath) == True:
                                    F_atoms_reshape.remove(Fat)
                        if os.path.exists(F_atoms_reshape[0].filepath) == False:
                            for Fat in F_atoms_reshape:
                                assert os.path.exists(Fat.filepath) == False, "Some input files already exist some do not"
                            F_atoms_reshape = app_get_snaps_from_traj(
                                execution_folder=self.input_folder,
                                stderr      = str(self.input_folder / str("error_"+str(k)+".txt")),
                                stdout      = str(self.input_folder / str("output_"+str(k)+".txt")),
                                inputs = [F_pre],
                                outputs = F_atoms_reshape, 
                                calib_step = self.pre_simulation.settings.calib_steps, 
                                set_vel = self.settings.set_vel,
                                ).outputs
                        count = 0
                        for i in range(self.num_runs-old_files):
                            for j in range(self.num_val_prop):
                                if (k*per_pre_file <= i*self.num_val_prop+j) and (i*self.num_val_prop+j < (k+1)*per_pre_file):
                                    F_atoms[j][old_files+i] = F_atoms_reshape[count]
                                    count+=1
                else:
                    for i in range(self.num_runs-old_files):
                        for j in range(self.num_val_prop):
                            if os.path.exists(F_atoms[j][old_files+i].filepath) == False:
                                F_atoms[j][old_files+i] = app_get_snaps_from_traj(
                                    execution_folder = self.input_folder,
                                    stderr      = str(self.input_folder / str("error"+self.suffix[j]+"_"+str(i)+".txt")),
                                    stdout      = str(self.input_folder / str("output"+self.suffix[j]+"_"+str(i)+".txt")),
                                    inputs = [self.pre_simulation.output_files[self.pre_val][-(i*self.num_val_prop+j)-1]],
                                    outputs = [F_atoms[j][old_files+i]], 
                                    calib_step = self.pre_simulation.settings.calib_steps, 
                                    set_vel = self.settings.set_vel,
                                    ).outputs[0]
            else:
                assert len(self.pre_simulation.output_files) == self.num_val_prop, "The number of pre-simulations does not match the number of validation properties"
                for j in range(self.num_val_prop):
                    per_pre_file = (self.num_runs-old_files) / len(self.pre_simulation.output_files[0][pre_files_ignore:])
                    if per_pre_file > 1.0:
                        for k, F_pre in enumerate(self.pre_simulation.output_files[j][pre_files_ignore:]):
                            F_atoms_reshape = []
                            for i in range(self.num_runs-old_files):
                                if (k*per_pre_file <= i) and (i < (k+1)*per_pre_file):
                                    F_atoms_reshape.append(F_atoms[j][old_files+i])
                            if os.path.exists(F_atoms_reshape[0].filepath) == False:
                                for Fat in F_atoms_reshape:
                                    assert os.path.exists(Fat.filepath) == False, "Some input files already exist some do not"
                                F_atoms_reshape = app_get_snaps_from_traj(
                                    execution_folder = self.input_folder,
                                    stderr      = str(self.input_folder / str("error"+self.suffix[j]+"_"+str(k)+".txt")),
                                    stdout      = str(self.input_folder / str("output"+self.suffix[j]+"_"+str(k)+".txt")),
                                    inputs = [F_pre],
                                    outputs = F_atoms_reshape, 
                                    calib_step = self.pre_simulation.settings.calib_steps, 
                                    set_vel = self.settings.set_vel,
                                    ).outputs
                            count = 0
                            for i in range(self.num_runs-old_files):
                                if (k*per_pre_file <= i) and (i < (k+1)*per_pre_file):
                                    F_atoms[j][old_files+i] = F_atoms_reshape[count]
                                    count+=1
                    else:
                        for i in range(self.num_runs-old_files):
                            if os.path.exists(F_atoms[j][old_files+i].filepath) == False:
                                F_atoms[j][old_files+i] = app_get_snaps_from_traj(
                                    execution_folder = self.input_folder,
                                    stderr      = str(self.input_folder / str("error"+self.suffix[j]+"_"+str(i)+".txt")),
                                    stdout      = str(self.input_folder / str("output"+self.suffix[j]+"_"+str(i)+".txt")),
                                    inputs = [self.pre_simulation.output_files[j][-i-1]],
                                    outputs = [F_atoms[j][old_files+i]], 
                                    calib_step = self.pre_simulation.settings.calib_steps, 
                                    set_vel = self.settings.set_vel,
                                    ).outputs[0]
        elif self.pre_Files != None:
            #Get atoms from pre_files
            for i in range(self.num_val_prop):
                for j in range(old_files, self.num_runs):
                    F_atoms[i][j] = self.pre_Files[i%len(self.pre_Files)][j%len(self.pre_Files[j])]
        
        #Create lower triangular
        if transform_low_tri:
            for i in range(self.num_val_prop):
                for j in range(old_files, self.num_runs):
                    low_tri = File(str(self.input_folder / str("tri_atoms"+self.suffix[j]+"_"+str(i)+".xyz")))
                    if os.path.exists(low_tri.filepath) == False:
                        F_atoms[i][j] = app_transform_lower_triangular(
                            execution_folder = self.input_folder, 
                            stderr      = str(self.input_folder / str("error_tri"+self.suffix[i]+"_"+str(j)+".txt")),
                            stdout      = str(self.input_folder / str("output_tri"+self.suffix[i]+"_"+str(j)+".txt")),
                            inputs = [F_atoms[i][j]], 
                            outputs = [low_tri], 
                            reorder = True
                            ).outputs[0]
                    else:
                        F_atoms[i][j] = low_tri
                
        #Create supercell
        if sup:
            assert self.settings.trans_mat is not None, "Transformation matrix not set"
            for i in range(self.num_val_prop):
                for j in range(old_files, self.num_runs):
                    sup_atoms = File(str(self.input_folder / str("sup_atoms"+self.suffix[i]+"_"+str(j)+".xyz")))
                    if os.path.exists(sup_atoms.filepath) == False:
                        F_atoms[i][j] = app_create_supercell(
                            execution_folder = self.input_folder, 
                            stderr      = str(self.input_folder / str("error_sup"+self.suffix[i]+"_"+str(j)+".txt")),
                            stdout      = str(self.input_folder / str("output_sup"+self.suffix[i]+"_"+str(j)+".txt")),
                            inputs = [F_atoms[i][j]], 
                            outputs = [sup_atoms], 
                            trans_mat = self.settings.trans_mat
                            ).outputs[0]
                    else:
                        F_atoms[i][j] = sup_atoms

        #Scale cell if needed
        if scale_cell:
            assert self.ref_cell != None, "Reference cell not set"
            for i in range(self.num_val_prop):
                for j in range(old_files, self.num_runs):
                    scaled_atoms = File(str(self.input_folder / str("scaled_atoms"+self.suffix[i]+"_"+str(j)+".xyz")))
                    if os.path.exists(scaled_atoms.filepath) == False:
                        F_atoms[i][j] = app_scale_cell(
                            execution_folder = self.input_folder, 
                            stderr      = str(self.input_folder / str("error_scale"+self.suffix[i]+"_"+str(j)+".txt")),
                            stdout      = str(self.input_folder / str("output_scale"+self.suffix[i]+"_"+str(j)+".txt")),
                            inputs = [F_atoms[i][j], self.ref_cell], 
                            outputs = [scaled_atoms]
                            ).outputs[0]
                    else:
                        F_atoms[i][j] = scaled_atoms

        #Set most ortho for all if needed
        if set_most_ortho:
            assert old_files == 0, "If you already have files then you cannot guarrantee that the new input files will be the same"
            for i in range(self.num_val_prop):
                ortho_atoms = []
                for j in range(self.num_runs):
                    ortho_atoms.append(File(str(self.input_folder / str("ortho_atoms"+self.suffix[i]+"_"+str(j)+".xyz"))))
                if os.path.exists(ortho_atoms[0].filepath) == False:
                    for j in range(self.num_runs):
                        assert os.path.exists(ortho_atoms[j].filepath) == False, "Some input files already exist some do not"
                    F_atoms[i] = app_set_most_ortho_forall(
                        execution_folder = self.input_folder, 
                        stderr      = str(self.input_folder / str("error_ortho"+self.suffix[i]+".txt")),
                        stdout      = str(self.input_folder / str("output_ortho"+self.suffix[i]+".txt")),
                        inputs  = F_atoms[i], 
                        outputs = ortho_atoms
                        ).outputs
                else:
                    F_atoms[i] = ortho_atoms
                                      
        self.input_files = F_atoms

    def set_ref_cell(self, Simulation):
        """
        Hard coded function!
        Function to set the reference cell for the simulation, normally extracted from NPT MD simulation
        """
        self.ref_cell = File(str(self.input_folder / str("ref_cell.xyz")))
        if os.path.exists(self.ref_cell.filepath) == False:
            self.ref_cell = app_get_snaps_from_traj(
                execution_folder = self.input_folder,
                inputs = Simulation.output_files[0],
                outputs = [self.ref_cell],
                scale_cell = True, 
                calib_step = Simulation.settings.calib_steps,
                set_vel = False,
                ).outputs[0]

    def get_weighted_snap(self, sup=False, old_files = 0, pre_files_ignore = 0):
        assert len(self.pre_simulation.output_files_rec) > 1, "weighted sampling is not implemented for runs at one setting, currently we use it only with recalculated NVT REX simulations"
        F_atoms= []
        for i in range(self.num_val_prop):
            inputs= []
            for j in range(pre_files_ignore, self.pre_simulation.num_runs):                
                if self.pre_val == None:
                    inputs.append(self.pre_simulation.output_files[i][j])
                    inputs.append(self.pre_simulation.output_files_rec[i][j])
                else:
                    inputs.append(self.pre_simulation.output_files[self.pre_val][j])
                    inputs.append(self.pre_simulation.output_files_rec[self.pre_val][j])    
            F_atoms.append([])
            for j in range(old_files, self.num_runs):
                F_atoms[i].append(File(str(self.input_folder / str("atoms"+self.suffix[i]+"_"+str(j)+".xyz"))))
                if os.path.exists(F_atoms[i][j].filepath) == False:
                    F_atoms[i][j] = app_get_weighted_random_snap(
                        self.settings.temperature[i],
                        execution_folder = self.input_folder,
                        stderr      = str(self.input_folder / str("error"+self.suffix[i]+"_"+str(j)+".txt")),
                        stdout      = str(self.input_folder / str("output"+self.suffix[i]+"_"+str(j)+".txt")),
                        inputs = inputs,
                        outputs = [F_atoms[i][j]], 
                        frac_MLP = self.settings.frac_MLP[i],
                        frac_bias= self.settings.frac_bias[i],
                        calib_step = self.pre_simulation.settings.calib_steps,            
                        ).outputs[0]

        #Create supercell
        if sup:
            assert self.settings.trans_mat != None, "Transformation matrix not set"
            for i in range(self.num_val_prop):
                for j in range(old_files, self.num_runs):
                    sup_atoms = File(str(self.input_folder / str("sup_atoms"+self.suffix[i]+"_"+str(j)+".xyz")))
                    if os.path.exists(sup_atoms.filepath) == False:
                        F_atoms[i][j] = app_create_supercell(
                            execution_folder = self.input_folder,
                            stderr      = str(self.input_folder / str("error_sup"+self.suffix[i]+"_"+str(j)+".txt")),
                            stdout      = str(self.input_folder / str("output_sup"+self.suffix[i]+"_"+str(j)+".txt")),
                            inputs  = [F_atoms[i][j]], 
                            outputs = [sup_atoms], 
                            trans_mat = self.settings.trans_mat,
                            ).outputs[0]
                    else:
                        F_atoms[i][j] = sup_atoms

        self.input_files = F_atoms

    def generate_restart_input(self, num_restarts):
        """
        Create input files from last snap of previous runs.
        Alternative is to use the restart option in perform simulation methods, this way the output files are appended and no new runs are needed.
        This alternative is however not well implemented and will hold the workflow until the previous runs are finished so this is the preferred method.
        """
        assert num_restarts <= self.num_runs, "Number of restarts is larger than number of runs to restart from"
        for i in range(self.num_val_prop):
            for j in range(self.num_runs, self.num_runs + num_restarts):
                self.input_files[i].append(File(str(self.input_folder / str("restart_atoms"+self.suffix[i]+"_"+str(j)+".xyz"))))
                if os.path.exists(self.input_files[i][j].filepath) == False:
                    self.input_files[i][j] = app_get_snaps_from_traj(
                        execution_folder = self.input_folder,
                        stderr      = str(self.input_folder / str("error_res"+self.suffix[i]+"_"+str(j)+".txt")),
                        stdout      = str(self.input_folder / str("output_res"+self.suffix[i]+"_"+str(j)+".txt")),
                        inputs =  self.input_files[i][j- num_restarts],
                        outputs = self.input_files[i][j], 
                        scale_cell = False, 
                        calib_step = self.pre_simulation.settings.calib_steps, 
                        set_vel = True,
                        ).outputs
        self.num_runs += num_restarts

    def perform_MD(self, restart = False, file_format = "h5"):
        """performs the MD run and sets the output files"""
        if self.output_files == None:
            self.output_files = []
        for i in range(self.num_val_prop):
            if len(self.output_files) <= i:
                self.output_files.append([])
            for j in range(self.num_runs):
                if len(self.output_files[i]) <= j:
                    self.output_files[i].append(File(str(self.output_folder / str("traj"+self.suffix[i]+"_"+str(j)+"."+file_format))))
                if os.path.exists(self.output_files[i][j].filepath) == False or restart:
                    inputs = [self.input_files[i][j], self.MLP_model_dct[self.settings.device + "_single"]]
                    if (self.min_struc is not None) and (self.Hessian_model is not None):
                        inputs.append(self.min_struc)
                        inputs.append(self.Hessian_model)
                    if restart:
                        while not self.output_files[i][j].done():
                            time.sleep(10)
                        #Enforce that the output files from which we restart are finished, be aware this will hold the workflow until they are finished
                        #The main reason for this is that it could be a problem for parsl to have inputs=outputs, therefore we need to wait until the output files are finished
                    self.output_files[i][j] = app_run_MD(
                        execution_folder=self.output_folder,
                        stderr      = str(self.output_folder / str("error_MD"+self.suffix[i]+"_"+str(j)+".txt")),
                        stdout      = str(self.output_folder / str("output_MD"+self.suffix[i]+"_"+str(j)+".txt")),
                        inputs      = inputs,
                        outputs     = [self.output_files[i][j]],
                        restart     = restart,
                        num_retries = self.num_retries,
                        device      = self.settings.device,            #sets the device to use, cpu or cuda
                        steps       = self.settings.nsteps, 
                        step        = self.settings.print_freq, 
                        temperature = self.settings.temperature[i], 
                        pressure    = self.settings.pressure[i], 
                        barostat    = self.settings.barostat,
                        frac_MLP    = self.settings.frac_MLP[i],
                        frac_bias   = self.settings.frac_bias[i],
                        seed        = j,
                        num_cores   = self.settings.num_cores,
                        ).outputs[0]

    def perform_REX(self, restart = False, file_format = "h5"):
        """performs the REX run and sets the output files"""
        if self.output_files == None:
            self.output_files = []
        for i in range(self.num_val_prop):
            if len(self.output_files) <= i:
                self.output_files.append([])
            for j in range(self.num_runs):
                if len(self.output_files[i]) <= j:
                    self.output_files[i].append(File(str(self.output_folder / str("traj"+self.suffix[i]+"_"+str(j)+"."+file_format))))
        for j in range(self.num_runs):
            if os.path.exists(self.output_files[0][j].filepath) == False or restart:
                outputs = [self.output_files[0][j]]
                inputs = [self.input_files[0][j]]
                for i in range(1,self.num_val_prop):
                    outputs.append(self.output_files[i][j])
                    inputs.append(self.input_files[i][j])
                    assert os.path.exists(self.output_files[i][j].filepath) == False or restart, "Some output files already exists, some do not"
                    assert self.settings.pressure[i] == self.settings.pressure[i-1], "All pressures must be the same for REX"
                    assert self.settings.frac_MLP[i] == self.settings.frac_MLP[i-1], "All frac_MLPs must be the same for REX"
                    assert self.settings.frac_bias[i] == self.settings.frac_bias[i-1], "All frac_bias must be the same for REX"
                outputs.append(File(str(self.output_folder / str("permutations_"+str(j)+".npy"))))
                inputs.append(self.MLP_model_dct[self.settings.device + "_single"])
                if self.settings.frac_MLP[i] != 1.0 or self.settings.frac_bias[i] != 0.0:
                    inputs.append(self.min_struc)
                    inputs.append(self.Hessian_model)
                if restart:
                    while not self.output_files[0][j].done():
                        time.sleep(10)
                    #Enforce that the output files from which we restart are finished, be aware this will hold the workflow until they are finished
                    #The main reason for this is that it could be a problem for parsl to have inputs=outputs, therefore we need to wait until the output files are finished
                app_REX = app_run_REX(
                    execution_folder=self.output_folder,
                    stderr      = str(self.output_folder / str("error_REX_"+str(j)+".txt")),
                    stdout      = str(self.output_folder / str("output_REX_"+str(j)+".txt")),
                    inputs      = inputs,
                    outputs     = outputs,
                    restart     = restart,
                    num_retries = self.num_retries,
                    num_replicas= self.num_val_prop,
                    device      = self.settings.device,            #sets the device to use, cpu or cuda
                    MC_attempts = self.settings.nsteps,
                    MD_steps    = self.settings.MD_steps_REX,
                    step        = self.settings.print_freq,
                    tem_min     = self.settings.temperature[0],
                    tem_max     = self.settings.temperature[-1],
                    pressure    = self.settings.pressure[0], 
                    barostat    = self.settings.barostat,
                    frac_MLP    = self.settings.frac_MLP[0],
                    frac_bias   = self.settings.frac_bias[0],
                    seed        = j,
                    num_cores   = self.settings.num_cores,
                    )
                for i in range(self.num_val_prop):
                    self.output_files[i][j] = app_REX.outputs[i]

    def perform_optimization(self):
        """performs the optimization run and sets the output files"""
        assert self.num_val_prop == 1, "Only one type of settings can be set for optimization simulation"

        if self.settings.pressure[0] == None:
            constant_cell = True
            constant_volume = True
        else:
            constant_cell = False
            constant_volume = False

        if self.output_files == None:  
            self.output_files = [[]]
        for i in range(self.num_runs):
            if len(self.output_files[0]) <= i:
                self.output_files[0].append(File(str(self.output_folder / str("opt_atoms"+self.suffix[0]+"_"+str(i)+".xyz"))))
            if os.path.exists(self.output_files[0][i].filepath) == False:
                #Optimize the structure
                inputs = [self.input_files[0][i], self.MLP_model_dct[self.settings.device + "_double"]]
                self.output_files[0][i] = app_optimize(
                    execution_folder=self.output_folder,
                    stderr         = str(self.output_folder / str("error_opt"+self.suffix[0]+"_"+str(i)+".txt")), 
                    stdout         = str(self.output_folder / str("output_opt"+self.suffix[0]+"_"+str(i)+".txt")), 
                    inputs         = inputs, 
                    outputs        = [self.output_files[0][i]], 
                    device         = self.settings.device,            #sets the device to use, cpu or cuda
                    constant_cell  = constant_cell, 
                    constant_volume= constant_volume,
                    fmax           = self.settings.fmax,
                    num_cores      = self.settings.num_cores,
                    ).outputs[0]

        #Get_min_struc
        if self.min_struc == None:
            self.min_struc = File(str(self.output_folder / str("min_struc"+self.suffix[0]+".xyz")))
        if os.path.exists(self.min_struc.filepath) == False:
            printoutfile = File(str(self.output_folder / str("Compare_minima"+self.suffix[0]+".txt")))
            self.min_struc = app_get_min_struc(
                execution_folder = self.output_folder,
                stderr      = str(self.output_folder / str("error_minstruc"+self.suffix[0]+".txt")),
                stdout      = str(self.output_folder / str("output_minstruc"+self.suffix[0]+".txt")),
                inputs  = self.output_files[0],
                outputs = [self.min_struc, printoutfile],
                ).outputs[0]
        return self.min_struc

    def calculate_hessian(self):
        #Calculate Hessian for lowest energy optimized structure
        if self.Hessian_npy == None:
            self.Hessian_npy   = File(str(self.output_folder / str("hessian_min"+self.suffix[0]+".npy")))
        if self.Hessian_model == None:
            self.Hessian_model = File(str(self.output_folder / str("Model_hessian_min"+self.suffix[0]+".pth")))
        if os.path.exists(self.Hessian_npy.filepath) == False:
            assert os.path.exists(self.Hessian_model.filepath) == False, "Some input files already exist some do not"
            app_hes = app_calc_hessian(
                model_type      = self.MLP_model_dct["model_type"],
                execution_folder= self.output_folder,
                stderr          = str(self.output_folder / str("error_hes"+self.suffix[0]+".txt")), 
                stdout          = str(self.output_folder / str("output_hes"+self.suffix[0]+".txt")), 
                inputs          = [self.min_struc, 
                                   self.MLP_model_dct[self.settings.device + "_double"], 
                                   self.MLP_model_dct["config"], 
                                   self.MLP_model_dct["undeployed"]
                                   ], 
                outputs         = [self.Hessian_npy, self.Hessian_model], 
                num_retries     = self.num_retries,
                device          = self.settings.device,            #sets the device to use, cpu or cuda
                num_cores       = self.settings.num_cores,
                )
            self.Hessian_npy = app_hes.outputs[0]
            self.Hessian_model = app_hes.outputs[1]
        return self.Hessian_npy, self.Hessian_model

    def perform_recalc(self, ind_lst = None, file_format = "h5", trans_traj = False):
        """performs the recalculation run and sets the recalc files"""
        if ind_lst == None:
            ind_lst = list(range(self.num_val_prop))
        else:
            for i, ind in enumerate(ind_lst):
                ind_lst[i] = ind%self.num_val_prop   #make sure the indices are in the correct range  (-1 --> len(self.num_val_prop) -1)

        if self.output_files_rec == None:
            self.output_files_rec = []
        for i in range(self.num_val_prop):
            if len(self.output_files_rec) <= i:
                self.output_files_rec.append([])
            for j in range(self.num_runs):
                if len(self.output_files_rec[i]) <= j:
                    self.output_files_rec[i].append(File(str(self.output_folder / str("recalc_traj"+self.suffix[i]+"_"+str(j)+"."+file_format))))
                if (os.path.exists(self.output_files_rec[i][j].filepath) == False) and (i in ind_lst):
                    inputs = [self.output_files[i][j], self.MLP_model_dct[self.settings.device + "_single"]]
                    inputs.append(self.min_struc)
                    inputs.append(self.Hessian_model)
                    self.output_files_rec[i][j] = app_run_recalc(
                        execution_folder= self.output_folder,
                        stderr          = str(self.output_folder / str("error_rec"+self.suffix[i]+"_"+str(j)+".txt")),
                        stdout          = str(self.output_folder / str("output_rec"+self.suffix[i]+"_"+str(j)+".txt")),
                        inputs          = inputs,
                        outputs         = [self.output_files_rec[i][j]],
                        device          = self.settings.device,            #sets the device to use, cpu or cuda
                        begin_frac_MLP  = self.settings.MLP_beg,
                        end_frac_MLP    = self.settings.MLP_end,
                        begin_frac_bias = self.settings.bias_beg,
                        end_frac_bias   = self.settings.bias_end,
                        num_cores       = self.settings.num_cores,
                        trans_traj      = trans_traj,
                        ).outputs[0]

    def create_pickle(self, temperature = None, lmd_np = None, ref_tem_lst = None, freq_max = 5.0, smear_freq = 0.02, bsize = 1024, num_part = 4):
        """creates a pickle file for the free energy contribution related to this simulation"""
        self.pickle_file = File(str(self.output_folder / str("fec.pickle")))
        if os.path.exists(self.pickle_file.filepath) == False:
            if self.Hessian_npy is not None:
                Plot_hes = File(str(self.output_folder / "Plot_spectra.pdf"))
                self.pickle_file = app_create_pickle_hes(
                    temperature, 
                    execution_folder = self.output_folder,
                    inputs=[self.min_struc, self.Hessian_npy], 
                    outputs= [self.pickle_file, Plot_hes],
                    freq_max = freq_max,
                    smear_freq = smear_freq,
                    ).outputs[0]
            elif self.settings.temperature[0] == None:
                Plot_vacf = File(str(self.output_folder / "Plot_spectra.pdf"))
                inputs = [self.min_struc]
                for i in range(self.num_val_prop):
                    for j in range(self.num_runs):
                        inputs.append(self.output_files[i][j])
                self.pickle_file = app_create_pickle_vacf(
                    self.num_val_prop,
                    self.num_runs,
                    temperature, 
                    execution_folder = self.output_folder,
                    inputs=inputs, 
                    outputs= [self.pickle_file, Plot_vacf],
                    bsize = bsize,
                    freq_max = freq_max,
                    ).outputs[0]
            elif self.settings.frac_MLP[0] != self.settings.frac_MLP[-1] or self.settings.frac_bias[0] != self.settings.frac_bias[-1]:
                Plot_lmd = File(str(self.output_folder / "Plot_delta_U.pdf"))
                inputs = [self.min_struc]
                for i in range(self.num_val_prop):
                    for j in range(self.num_runs):
                        inputs.append(self.output_files_rec[i][j])
                assert len(self.ref_pickle_file_lst) == 1, "Only one reference pickle file is allowed"
                inputs.append(self.ref_pickle_file_lst[0])
                self.pickle_file = app_create_pickle_lmdTI(
                    self.num_val_prop,
                    self.num_runs,
                    lmd_np, 
                    execution_folder = self.output_folder,
                    inputs = inputs,
                    outputs = [self.pickle_file, Plot_lmd],
                    temperature = self.settings.temperature[0],
                    num_part = num_part,
                    calib = self.settings.calib_steps,
                    ).outputs[0]
            elif self.settings.temperature[0] != self.settings.temperature[-1]:
                Plot_temp = File(str(self.output_folder / "Plot_anharm_U.pdf"))
                inputs = [self.min_struc]
                for i in range(self.num_val_prop):
                    for j in range(self.num_runs):
                        inputs.append(self.output_files[i][j])
                for pfile in self.ref_pickle_file_lst:
                    inputs.append(pfile)
                self.pickle_file = app_create_pickle_temTI(
                    self.num_val_prop,
                    self.num_runs,
                    self.settings.temperature, 
                    execution_folder = self.output_folder,
                    inputs = inputs,
                    outputs = [self.pickle_file, Plot_temp],
                    pressure = self.settings.pressure[0],
                    ref_tem_lst = ref_tem_lst,
                    num_part = num_part,
                    calib = self.settings.calib_steps,
                    ).outputs[0]
            elif self.settings.pressure[0] is not None:
                Plot_nptd = File(str(self.output_folder / "Plot_smoothed_distribution.pdf"))
                inputs = [self.min_struc]
                for i in range(self.num_val_prop):
                    for j in range(self.num_runs):
                        inputs.append(self.output_files[i][j])
                assert len(self.ref_pickle_file_lst) == 1, "Only one reference pickle file is allowed"
                inputs.append(self.ref_pickle_file_lst[0])
                self.pickle_file = app_create_pickle_nptd(
                    self.num_val_prop,
                    self.num_runs,
                    self.settings.temperature[0],
                    self.settings.pressure,
                    execution_folder = self.output_folder,
                    inputs=inputs,
                    outputs= [self.pickle_file, Plot_nptd], 
                    num_part = num_part,
                    calib = self.settings.calib_steps,
                    ).outputs[0]
    